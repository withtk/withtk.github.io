import React, { useState, useEffect } from 'react';

const OthelloGame = () => {
const BOARD_SIZE = 8;
const EMPTY = 0;
const BLACK = 1;
const WHITE = 2;

// ì´ˆê¸° ë³´ë“œ ì„¤ì •
const initializeBoard = () => {
const board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(EMPTY));
// ì´ˆê¸° 4ê°œ ëŒ ë°°ì¹˜
board[3][3] = WHITE;
board[3][4] = BLACK;
board[4][3] = BLACK;
board[4][4] = WHITE;
return board;
};

const [board, setBoard] = useState(initializeBoard);
const [currentPlayer, setCurrentPlayer] = useState(BLACK);
const [gameOver, setGameOver] = useState(false);
const [scores, setScores] = useState({ black: 2, white: 2 });
const [animatingDiscs, setAnimatingDiscs] = useState(new Set());
const [placingDisc, setPlacingDisc] = useState(null);

// 8ë°©í–¥ ë²¡í„°
const directions = [
[-1, -1], [-1, 0], [-1, 1],
[0, -1],           [0, 1],
[1, -1],  [1, 0],  [1, 1]
];

// ìœ íš¨í•œ ì¢Œí‘œì¸ì§€ í™•ì¸
const isValidPosition = (row, col) => {
return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
};

// íŠ¹ì • ë°©í–¥ìœ¼ë¡œ ë’¤ì§‘ì„ ìˆ˜ ìˆëŠ” ëŒë“¤ ì°¾ê¸°
const findFlippableDiscs = (board, row, col, player, direction) => {
const [dRow, dCol] = direction;
const flippable = [];
let currentRow = row + dRow;
let currentCol = col + dCol;

while (isValidPosition(currentRow, currentCol)) {
const cell = board[currentRow][currentCol];

if (cell === EMPTY) {
return []; // ë¹ˆ ì¹¸ì„ ë§Œë‚˜ë©´ ë’¤ì§‘ì„ ìˆ˜ ì—†ìŒ
} else if (cell === player) {
return flippable; // ìì‹ ì˜ ëŒì„ ë§Œë‚˜ë©´ ì¤‘ê°„ì— ìˆë˜ ìƒëŒ€ë°© ëŒë“¤ì„ ë’¤ì§‘ì„ ìˆ˜ ìˆìŒ
} else {
flippable.push([currentRow, currentCol]); // ìƒëŒ€ë°© ëŒ ì¶”ê°€
}

currentRow += dRow;
currentCol += dCol;
}

return []; // ë³´ë“œ ëê¹Œì§€ ê°€ë„ ìì‹ ì˜ ëŒì„ ëª» ë§Œë‚˜ë©´ ë’¤ì§‘ì„ ìˆ˜ ì—†ìŒ
};

// í•´ë‹¹ ìœ„ì¹˜ì— ëŒì„ ë†“ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
const isValidMove = (board, row, col, player) => {
if (board[row][col] !== EMPTY) return false;

for (const direction of directions) {
const flippable = findFlippableDiscs(board, row, col, player, direction);
if (flippable.length > 0) return true;
}
return false;
};

// ê°€ëŠ¥í•œ ëª¨ë“  ìˆ˜ ì°¾ê¸°
const findValidMoves = (board, player) => {
const validMoves = [];
for (let row = 0; row < BOARD_SIZE; row++) {
for (let col = 0; col < BOARD_SIZE; col++) {
if (isValidMove(board, row, col, player)) {
validMoves.push([row, col]);
}
}
}
return validMoves;
};

// ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜ (ì¤‘ì‹¬ì ì—ì„œì˜ ê±°ë¦¬)
const getDistanceFromCenter = (row1, col1, row2, col2) => {
return Math.sqrt(Math.pow(row2 - row1, 2) + Math.pow(col2 - col1, 2));
};

// ëŒ ë†“ê¸°
const makeMove = async (row, col) => {
if (gameOver || !isValidMove(board, row, col, currentPlayer) || animatingDiscs.size > 0) return;

// ìƒˆ ëŒ ë°°ì¹˜ ì• ë‹ˆë©”ì´ì…˜
setPlacingDisc(`${row}-${col}`);

const newBoard = board.map(row => [...row]);
newBoard[row][col] = currentPlayer;

// ë’¤ì§‘ì„ ëŒë“¤ ìˆ˜ì§‘
const allFlippableDiscs = [];
for (const direction of directions) {
const flippable = findFlippableDiscs(board, row, col, currentPlayer, direction);
allFlippableDiscs.push(...flippable);
}

// ê±°ë¦¬ì— ë”°ë¼ ì •ë ¬ (ê°€ê¹Œìš´ ê²ƒë¶€í„°)
allFlippableDiscs.sort((a, b) => {
const distA = getDistanceFromCenter(row, col, a[0], a[1]);
const distB = getDistanceFromCenter(row, col, b[0], b[1]);
return distA - distB;
});

// ëŒ ë°°ì¹˜ í›„ ì ì‹œ ëŒ€ê¸°
setTimeout(() => {
setPlacingDisc(null);
setBoard(newBoard);

// ìˆœì°¨ì ìœ¼ë¡œ ëŒ ë’¤ì§‘ê¸° ì• ë‹ˆë©”ì´ì…˜
allFlippableDiscs.forEach((discPos, index) => {
setTimeout(() => {
const discKey = `${discPos[0]}-${discPos[1]}`;
setAnimatingDiscs(prev => new Set([...prev, discKey]));

// ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì‹¤ì œ ëŒ ìƒ‰ìƒ ë³€ê²½
setTimeout(() => {
setBoard(prevBoard => {
const updatedBoard = prevBoard.map(row => [...row]);
updatedBoard[discPos[0]][discPos[1]] = currentPlayer;
return updatedBoard;
});

setAnimatingDiscs(prev => {
const newSet = new Set(prev);
newSet.delete(discKey);
return newSet;
});

// ë§ˆì§€ë§‰ ëŒ ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚¬ì„ ë•Œ ë‹¤ìŒ í”Œë ˆì´ì–´ë¡œ ì „í™˜
if (index === allFlippableDiscs.length - 1) {
setTimeout(() => {
const nextPlayer = currentPlayer === BLACK ? WHITE : BLACK;
const nextPlayerMoves = findValidMoves(newBoard, nextPlayer);
const currentPlayerMoves = findValidMoves(newBoard, currentPlayer);

if (nextPlayerMoves.length > 0) {
setCurrentPlayer(nextPlayer);
} else if (currentPlayerMoves.length > 0) {
// ìƒëŒ€ë°©ì´ ë‘˜ ìˆ˜ ì—†ìœ¼ë©´ í˜„ì¬ í”Œë ˆì´ì–´ ê³„ì†
} else {
// ë‘˜ ë‹¤ ë‘˜ ìˆ˜ ì—†ìœ¼ë©´ ê²Œì„ ì¢…ë£Œ
setGameOver(true);
}
}, 100);
}
}, 500); // ë’¤ì§‘ê¸° ì• ë‹ˆë©”ì´ì…˜ ì§€ì† ì‹œê°„
}, index * 120); // ìˆœì°¨ì  ì• ë‹ˆë©”ì´ì…˜ ë”œë ˆì´
});
}, 300); // ëŒ ë°°ì¹˜ í›„ ëŒ€ê¸° ì‹œê°„
};

// ì ìˆ˜ ê³„ì‚°
useEffect(() => {
let blackCount = 0;
let whiteCount = 0;

for (let row = 0; row < BOARD_SIZE; row++) {
for (let col = 0; col < BOARD_SIZE; col++) {
if (board[row][col] === BLACK) blackCount++;
else if (board[row][col] === WHITE) whiteCount++;
}
}

setScores({ black: blackCount, white: whiteCount });
}, [board]);

// ê²Œì„ ì¬ì‹œì‘
const resetGame = () => {
setBoard(initializeBoard());
setCurrentPlayer(BLACK);
setGameOver(false);
setScores({ black: 2, white: 2 });
setAnimatingDiscs(new Set());
setPlacingDisc(null);
};

// ê°€ëŠ¥í•œ ìˆ˜ í‘œì‹œ
const validMoves = findValidMoves(board, currentPlayer);

const getWinner = () => {
if (scores.black > scores.white) return 'BLACK';
if (scores.white > scores.black) return 'WHITE';
return 'TIE';
};

return (
<div className="flex flex-col items-center p-6 bg-gradient-to-br from-green-100 to-green-200 min-h-screen">
  <style jsx>{`
  @keyframes flipDisc {
  0% { transform: perspective(100px) rotateY(0deg) scale(1); }
  50% { transform: perspective(100px) rotateY(90deg) scale(1.1); }
  100% { transform: perspective(100px) rotateY(180deg) scale(1); }
  }

  @keyframes placeDisc {
      0% { transform: scale(0) rotate(0deg); opacity: 0; }
      50% { transform: scale(1.2) rotate(180deg); opacity: 0.8; }
      100% { transform: scale(1) rotate(360deg); opacity: 1; }
  }

  @keyframes validMoveGlow {
      0%, 100% { opacity: 0.5; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
  }

  .flip-animation {
      animation: flipDisc 0.5s ease-in-out;
  }

  .place-animation {
      animation: placeDisc 0.3s ease-out;
  }

  .valid-move-glow {
      animation: validMoveGlow 2s ease-in-out infinite;
  }

  .disc-shadow {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), inset 0 2px 4px rgba(255, 255, 255, 0.2);
  }

  .board-cell {
      background: linear-gradient(145deg, #16a34a, #15803d);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .board-cell:hover {
      background: linear-gradient(145deg, #22c55e, #16a34a);
  }
      `}</style>

  <h1 className="text-4xl font-bold mb-6 text-green-800 drop-shadow-lg">ì˜¤ì…€ë¡œ (Othello)</h1>

  {/* ì ìˆ˜íŒ */}
  <div className="flex gap-8 mb-6 text-xl font-semibold">
    <div className={`flex items-center gap-3 px-6 py-3 rounded-xl transition-all duration-300 ${
         currentPlayer === BLACK ? 'bg-gray-800 text-white shadow-lg transform scale-105' : 'bg-white shadow-md'
    }`}>
    <div className="w-8 h-8 bg-black rounded-full disc-shadow"></div>
    <span>í‘: {scores.black}</span>
  </div>
  <div className={`flex items-center gap-3 px-6 py-3 rounded-xl transition-all duration-300 ${
       currentPlayer === WHITE ? 'bg-gray-800 text-white shadow-lg transform scale-105' : 'bg-white shadow-md'
  }`}>
  <div className="w-8 h-8 bg-white border-2 border-gray-400 rounded-full disc-shadow"></div>
  <span>ë°±: {scores.white}</span>
</div>
</div>

{/* ê²Œì„ ìƒíƒœ */}
<div className="mb-6 text-lg font-medium">
  {gameOver ? (
  <div className="text-center bg-white rounded-xl p-6 shadow-lg">
    <div className="text-3xl font-bold mb-3 text-green-800">ê²Œì„ ì¢…ë£Œ!</div>
    <div className="text-xl">
      {getWinner() === 'TIE' ? 'ğŸ¤ ë¬´ìŠ¹ë¶€!' :
      getWinner() === 'BLACK' ? 'âš« í‘ëŒ ìŠ¹ë¦¬!' : 'âšª ë°±ëŒ ìŠ¹ë¦¬!'}
    </div>
  </div>
  ) : (
  <div className="flex items-center gap-3 bg-white rounded-xl px-6 py-3 shadow-lg">
    <div className={`w-6 h-6 rounded-full disc-shadow transition-all duration-300 ${
         currentPlayer === BLACK ? 'bg-black' : 'bg-white border-2 border-gray-400'
    }`}></div>
  <span className="text-green-800">
              {currentPlayer === BLACK ? 'í‘ëŒ' : 'ë°±ëŒ'}ì˜ ì°¨ë¡€
              {animatingDiscs.size > 0 && ' (ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ ì¤‘...)'}
            </span>
</div>
)}
</div>

{/* ê²Œì„ ë³´ë“œ */}
<div className="grid grid-cols-8 gap-2 bg-green-900 p-4 rounded-2xl mb-6 shadow-2xl">
  {board.map((row, rowIndex) =>
  row.map((cell, colIndex) => {
  const cellKey = `${rowIndex}-${colIndex}`;
  const isValidMovePosition = validMoves.some(([r, c]) => r === rowIndex && c === colIndex);
  const isAnimating = animatingDiscs.has(cellKey);
  const isPlacing = placingDisc === cellKey;

  return (
  <button
    key={cellKey}
    className={`w-14 h-14 board-cell border border-green-700 rounded-lg flex items-center justify-center transition-all duration-200 ${
    isValidMovePosition && !gameOver && animatingDiscs.size === 0 ? 'ring-2 ring-yellow-400 ring-opacity-70' : ''
  } ${animatingDiscs.size === 0 ? 'hover:scale-105' : ''}`}
  onClick={() => makeMove(rowIndex, colIndex)}
  disabled={gameOver || animatingDiscs.size > 0}
  >
  {cell === BLACK && (
  <div className={`w-12 h-12 bg-black rounded-full disc-shadow transition-all duration-200 ${
       isAnimating ? 'flip-animation' : ''
  } ${isPlacing ? 'place-animation' : ''}`}></div>
)}
{cell === WHITE && (
<div className={`w-12 h-12 bg-white rounded-full disc-shadow border-2 border-gray-300 transition-all duration-200 ${
     isAnimating ? 'flip-animation' : ''
} ${isPlacing ? 'place-animation' : ''}`}></div>
)}
{cell === EMPTY && isValidMovePosition && !gameOver && animatingDiscs.size === 0 && (
<div className="w-4 h-4 bg-yellow-400 rounded-full valid-move-glow shadow-lg"></div>
)}
</button>
);
})
)}
</div>

{/* ê²Œì„ ì •ë³´ */}
<div className="text-center text-sm text-gray-700 mb-6 max-w-md bg-white bg-opacity-80 rounded-lg p-4 shadow-md">
  <p className="mb-2">â­ ë…¸ë€ ì ì´ í‘œì‹œëœ ìœ„ì¹˜ì— ëŒì„ ë†“ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
  <p>ğŸ¯ ìƒëŒ€ë°©ì˜ ëŒì„ ì–‘ìª½ì—ì„œ ê°ì‹¸ë©´ ê·¸ ëŒë“¤ì´ ë‚´ ëŒë¡œ ë°”ë€ë‹ˆë‹¤.</p>
</div>

{/* ì¬ì‹œì‘ ë²„íŠ¼ */}
<button
  onClick={resetGame}
  disabled={animatingDiscs.size > 0}
  className={`px-8 py-4 rounded-xl font-semibold text-lg transition-all duration-300 transform ${
  animatingDiscs.size > 0
  ? 'bg-gray-400 text-gray-600 cursor-not-allowed'
  : 'bg-blue-600 text-white hover:bg-blue-700 hover:scale-105 shadow-lg hover:shadow-xl'
  }`}
  >
  ğŸ® ìƒˆ ê²Œì„
</button>
</div>
);
};

export default OthelloGame;